"use strict";(self.webpackChunkroutr_docs=self.webpackChunkroutr_docs||[]).push([[1668],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),d=o,h=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return n?r.createElement(h,s(s({ref:t},p),{},{components:n})):r.createElement(h,s({ref:t},p))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2604:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={},s="RTPRelay",i={unversionedId:"development/components/rtprelay",id:"development/components/rtprelay",title:"RTPRelay",description:"The RTPRelay is an optional middleware service that can control RTPEngine instances. The RTPRelay component enables interoperability between WebRTC-based clients, such as SIP.js, and legacy SIP clients. Another use case for the RTPRelay is to help SIP clients who cannot send and receive media directly.",source:"@site/docs/development/components/rtprelay.md",sourceDirName:"development/components",slug:"/development/components/rtprelay",permalink:"/docs/2.0.0/development/components/rtprelay",draft:!1,editUrl:"https://github.com/fonoster/routr-website/edit/main/docs/development/components/rtprelay.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Requester",permalink:"/docs/2.0.0/development/components/requester"},next:{title:"APIServer",permalink:"/docs/2.0.0/development/components/apiserver"}},l={},c=[{value:"Configuration Spec",id:"configuration-spec",level:2},{value:"Communication and Protobuf Spec",id:"communication-and-protobuf-spec",level:2},{value:"Launching the RTPRelay with Docker",id:"launching-the-rtprelay-with-docker",level:2},{value:"Quick Test with gRPCurl",id:"quick-test-with-grpcurl",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"rtprelay"},"RTPRelay"),(0,o.kt)("p",null,"The RTPRelay is an optional middleware service that can control RTPEngine instances. The RTPRelay component enables interoperability between WebRTC-based clients, such as SIP.js, and legacy SIP clients. Another use case for the RTPRelay is to help SIP clients who cannot send and receive media directly."),(0,o.kt)("h2",{id:"configuration-spec"},"Configuration Spec"),(0,o.kt)("p",null,"Unlike other components, the RTPRelay service does not have a configuration file. However, the following environment is to configure the service:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"BIND_ADDR")," - The IP address and port to bind the gRPC server. Defaults to ",(0,o.kt)("inlineCode",{parentName:"li"},"0.0.0.0:51903")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RTPENGINE_HOST")," - The IP address or hostname of the RTPEngine service. Required."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RTPENGINE_PORT")," - The port of the RTPEngine service. Defaults to ",(0,o.kt)("inlineCode",{parentName:"li"},"22222"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RTPENGINE_TIMEOUT")," - The timeout in milliseconds for the RTPEngine service. Defaults to ",(0,o.kt)("inlineCode",{parentName:"li"},"5000"),".")),(0,o.kt)("h2",{id:"communication-and-protobuf-spec"},"Communication and Protobuf Spec"),(0,o.kt)("p",null,'Services communicate with RTPRelay service using gRPC. The RTPRelay, in turn, communicates with RTPEngine using the "ng protocol." The contract for communication with RTPRelay service consists of the following protobuf:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\n\npackage fonoster.routr.processor.v2beta1;\n\nimport "common.proto";\nimport "sipmessage.proto";\n\n// Processor service\nservice Processor {\n  // Process Message Request\n  rpc ProcessMessage (MessageRequest) returns (MessageResponse) {}\n}\n\nenum Method {\n  UNKNOWN = 0;\n  // Communicates user location (hostname, IP)\n  REGISTER = 1;\n  // Establishes a session\n  INVITE = 2;\n  // Transports Instant Messages\n  MESSAGE = 3;\n  // Publishes an event to the Server\n  PUBLISH = 4;\n  // Notifies the subscriber of a new event\n  NOTIFY = 5;\n  // Subscribes for Notification from the notifier\n  SUBSCRIBE = 6;\n  // Confirms an INVITE request\n  ACK = 7;\n  // Terminates a session\n  BYE = 8;\n  // Cancels establishing of a session\n  CANCEL = 9;\n  // Communicates information about the capabilities of calling and receiving SIP phones\n  OPTIONS = 10;\n  // Provisional Acknowledgement\n  PRACK = 11;\n  // Sends mid-session information\n  INFO = 12;\n  // Asks the recipient to issue a call transfer\n  REFER = 13;\n  // Modifies the state of a session\n  UPDATE = 14;\n}\n\nmessage NetInterface {\n  string host = 1;\n  int32 port = 2;\n  fonoster.routr.common.v2beta1.Transport transport = 3;\n}\n\nmessage MessageRequest {\n  // Same as the Call-Id header \n  string ref = 1;\n  string edge_port_ref = 2;\n  Method method = 3;\n  NetInterface sender = 4;\n  repeated NetInterface listening_points = 5;\n  repeated string external_addrs = 6;\n  repeated string localnets = 7;\n  fonoster.routr.sipmessage.v2beta1.SIPMessage message = 8;\n  map<string, string> metadata = 9;\n}\n\nmessage MessageResponse {\n  NetInterface sender = 1;\n  fonoster.routr.sipmessage.v2beta1.SIPMessage message = 2;\n  map<string, string> metadata = 3;\n}\n')),(0,o.kt)("p",null,"Link to the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fonoster/routr/blob/main/mods/common/src/protos/processor.proto"},"protobuf definition.")),(0,o.kt)("h2",{id:"launching-the-rtprelay-with-docker"},"Launching the RTPRelay with Docker"),(0,o.kt)("p",null,"The RTPRelay is available as a Docker image from ",(0,o.kt)("a",{parentName:"p",href:"https://hub.docker.com/r/fonoster/routr-rtprelay"},"Docker Hub"),". To launch the RTPRelay with Docker, you can use the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'docker run -it -e RTPENGINE_HOST="rtpengine" -p 51903:51903 fonoster/routr-rtprelay\n')),(0,o.kt)("p",null,"The previous example will pull the latest version of the RTPRelay from Docker Hub and launch the service. The service will listen on the default port, ",(0,o.kt)("inlineCode",{parentName:"p"},"51903"),", for gRPC requests. Remember, your Docker container must expose the service's ports, too."),(0,o.kt)("h2",{id:"quick-test-with-grpcurl"},"Quick Test with gRPCurl"),(0,o.kt)("p",null,"One easy way to interact with the RTPRelay for testing and development is to use ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstorydev/grpcurl"},"gRPCurl"),". The following example shows how to send a SIP Message to the RTPRelay."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"grpcurl -plaintext \\\n  -import-path /path/to/protos \\\n  -proto processor.proto  -d '{...}' \\\n  localhost:51901 \\\n  fonoster.routr.processor.v2beta1.Processor/ProcessMessage\n")))}m.isMDXComponent=!0}}]);